const express=require("express"),router=express.Router(),gravatar=require("gravatar"),bcrypt=require("bcryptjs"),auth=require("../../middleware/auth"),jwt=require("jsonwebtoken"),{check:check,validationResult:validationResult}=require("express-validator"),normalize=require("normalize-url"),config=require("../../config"),User=require("../../models/User"),Stake=require("../../models/Stake");router.post("/sendRequest",async(req,res)=>{const{userPass:userPass,stakeAmount:stakeAmount}=req.body;console.log(req.body);try{var date=new Date;let newDate=new Date(date.setDate(date.getDate()+30)),stakesOfNow=await Stake.find({$or:[{waitStatus:1},{waitStatus:2},{waitStatus:3}]});stake=new Stake({userPass:userPass,stakeIndex:stakesOfNow.length+1,stakeAmount:stakeAmount,endDate:newDate,waitStatus:2,newFlag:0}),await stake.save(),res.json({msg:"success"})}catch(err){console.error(err.message),res.status(500).send("Server error")}}),router.post("/sendUnStakeRequest",async(req,res)=>{const{userPass:userPass}=req.body;try{await Stake.updateOne({userPass:userPass},{$set:{waitStatus:3}}),res.json({msg:"success"})}catch(err){console.error(err.message),res.status(500).send("Server error")}}),router.post("/sendUnStakeResponse",async(req,res)=>{const{userPass:userPass}=req.body;try{await Stake.updateOne({userPass:userPass},{$set:{waitStatus:0}}),res.json({msg:"success"})}catch(err){console.error(err.message),res.status(500).send("Server error")}}),router.post("/sendUnStakeRejectResponse",async(req,res)=>{const{userPass:userPass}=req.body;try{console.log("------- reject -------",userPass),await Stake.updateOne({userPass:userPass},{$set:{waitStatus:2}}),res.json({msg:"success"})}catch(err){console.error(err.message),res.status(500).send("Server error")}}),router.post("/changeNewFlag",async(req,res)=>{const{id:id}=req.body;console.log(id);try{let stakes=await Stake.updateOne({_id:id},{$set:{newFlag:!0}});res.json({msg:"changeNewFlag"})}catch(err){console.error(err.message),res.status(500).send("Server error")}}),router.get("/getStake",async(req,res)=>{try{let stakes=await Stake.find({$or:[{waitStatus:1},{waitStatus:2},{waitStatus:3}]}).sort({endDate:-1,newFlag:1});console.log(stakes);let nstakes=stakes.map(item=>{var current=Date.now()/1e3,ms=Date.parse(item.endDate)/1e3;if(current<ms&&0!==item.waitStatus){console.log("eeee",30-(ms-current)/60/60/24);var reward=((30-(ms-current)/60/60/24)*item.stakeAmount*.01).toFixed(3);return console.log("--reward",reward),item=Object.assign({reward:reward},item)}});res.json({stake:nstakes})}catch(err){console.error(err.message),res.status(500).send("Server error")}}),router.post("/changeStatus",async(req,res)=>{const{ids:ids,changeStatus:changeStatus}=req.body;try{var date=new Date;console.log(date);let newDate=new Date(date.setDate(date.getDate()+30)),stakes=await Stake.updateOne({_id:ids},{$set:{waitStatus:changeStatus,endDate:newDate}});console.log(stakes),res.json({stake:stakes})}catch(err){console.error("err-end",err.message),res.status(500).send("Server error")}}),router.post("/getById",async(req,res)=>{const{userPass:userPass}=req.body;try{stake=await Stake.find({userPass:userPass}),console.log("--stake",stake);var current=Date.now()/1e3,ms=Date.parse(stake[0].endDate)/1e3;if(current<ms&&0!==stake[0].waitStatus){var reward=((30-(ms-current)/60/60/24)*stake[0].stakeAmount*.01).toFixed(3);console.log(reward),res.json({stake:stake,reward:reward})}else res.json({msg:"noStake"})}catch(err){console.error(err.message),res.status(500).send("Server error")}}),router.post("/delete",async(req,res)=>{const{userPass:userPass}=req.body;try{Stake.deleteMany().then(res=>{console.log("success delete")}),res.json({msg:"delete success"})}catch(err){res.status(500).send("Server error")}}),module.exports=router;